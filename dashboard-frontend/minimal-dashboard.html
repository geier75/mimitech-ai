<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MISO Ultimate Dashboard - Minimal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .status-card:hover {
            transform: translateY(-5px);
        }
        
        .status-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .status-value {
            font-size: 2em;
            font-weight: bold;
            color: #27ae60;
        }
        
        .voice-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .mic-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .mic-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .mic-button.listening {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .voice-status {
            flex: 1;
        }
        
        .voice-feedback {
            background: #ecf0f1;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            min-height: 60px;
        }
        
        .benchmark-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .benchmark-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .benchmark-card:hover {
            transform: translateY(-5px);
        }
        
        .benchmark-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        
        .benchmark-button:hover {
            background: linear-gradient(45deg, #229954, #27ae60);
            transform: translateY(-2px);
        }
        
        .benchmark-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .results {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ MISO Ultimate Dashboard</h1>
            <p>Sprachgesteuerte Benchmark-Ausf√ºhrung</p>
        </div>
        
        <div class="status-grid">
            <div class="status-card">
                <h3>üñ•Ô∏è Server Status</h3>
                <div class="status-value" id="server-status">Laden...</div>
            </div>
            <div class="status-card">
                <h3>‚ö° Verf√ºgbare Tools</h3>
                <div class="status-value" id="tools-count">Laden...</div>
            </div>
            <div class="status-card">
                <h3>üìä Letzte Ausf√ºhrung</h3>
                <div class="status-value" id="last-run">Keine</div>
            </div>
        </div>
        
        <div class="voice-section">
            <h2>üé§ Sprachsteuerung</h2>
            <div class="voice-controls">
                <button class="mic-button" id="mic-button" onclick="toggleVoiceRecognition()">
                    üé§
                </button>
                <div class="voice-status">
                    <h3 id="voice-status-text">Klicken Sie auf das Mikrofon</h3>
                    <p><strong>Verf√ºgbare Befehle:</strong> "Matrix Benchmark", "Quantum Benchmark", "Alle Benchmarks", "Status", "Hilfe"</p>
                </div>
            </div>
            <div class="voice-feedback" id="voice-feedback">
                Bereit f√ºr Sprachbefehle...
            </div>
        </div>
        
        <div class="benchmark-grid">
            <div class="benchmark-card">
                <h3>üî¢ Matrix Benchmark</h3>
                <p>Matrix-Multiplikation mit konfigurierbaren Parametern</p>
                <button class="benchmark-button" onclick="runBenchmark('benchmark_matrix')">
                    Matrix Benchmark starten
                </button>
            </div>
            
            <div class="benchmark-card">
                <h3>‚öõÔ∏è Quantum Benchmark</h3>
                <p>Quantum Computing Simulation Benchmark</p>
                <button class="benchmark-button" onclick="runBenchmark('benchmark_quantum')">
                    Quantum Benchmark starten
                </button>
            </div>
            
            <div class="benchmark-card">
                <h3>üîÑ Alle Benchmarks</h3>
                <p>Umfassende Benchmark-Suite</p>
                <button class="benchmark-button" onclick="runBenchmark('benchmark_all')">
                    Alle Benchmarks starten
                </button>
            </div>

            <div class="benchmark-card" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white;">
                <h3>üé§ Voice Control</h3>
                <p>Sprachsteuerung und Text-Eingabe</p>

                <!-- Text Input als Fallback -->
                <div style="margin-bottom: 15px;">
                    <input type="text" id="voice-text-input" placeholder="Befehl eingeben: matrix, quantum, status..."
                           style="width: 100%; padding: 8px; border: none; border-radius: 5px; font-size: 0.9em;">
                    <button onclick="processTextCommand()" style="width: 100%; margin-top: 5px; padding: 8px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; cursor: pointer;">
                        üìù Text-Befehl ausf√ºhren
                    </button>
                </div>

                <!-- Audio Recording -->
                <button id="whisper-voice-button" class="benchmark-button" onclick="toggleWhisperRecording()" style="background: rgba(255,255,255,0.2); border: 2px solid white;">
                    üé§ Audio-Aufnahme
                </button>

                <!-- Alternative: File Upload -->
                <div style="margin-top: 10px;">
                    <input type="file" id="audio-file-input" accept="audio/*" style="display: none;" onchange="processAudioFile(this)">
                    <button onclick="document.getElementById('audio-file-input').click()" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; cursor: pointer;">
                        üìÅ Audio-Datei hochladen
                    </button>
                </div>

                <div id="whisper-status" style="margin-top: 10px; font-size: 0.9em; opacity: 0.9;">
                    Bereit f√ºr Sprach- oder Text-Eingabe
                </div>

                <!-- Quick Test Buttons -->
                <div style="margin-top: 10px;">
                    <button onclick="simulateWhisperCommand('matrix')" style="padding: 5px 10px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; font-size: 0.8em; cursor: pointer;">
                        ‚ö° Matrix
                    </button>
                    <button onclick="simulateWhisperCommand('quantum')" style="padding: 5px 10px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; font-size: 0.8em; cursor: pointer; margin-left: 5px;">
                        ‚ö° Quantum
                    </button>
                    <button onclick="simulateWhisperCommand('status')" style="padding: 5px 10px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; font-size: 0.8em; cursor: pointer; margin-left: 5px;">
                        ‚ö° Status
                    </button>
                    <button onclick="testWithJFKAudio()" style="padding: 5px 10px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; font-size: 0.8em; cursor: pointer; margin-left: 5px;">
                        üéµ JFK Test
                    </button>
                    <button onclick="testMicrophone()" style="padding: 5px 10px; background: rgba(255,255,255,0.3); border: 1px solid white; border-radius: 5px; color: white; font-size: 0.8em; cursor: pointer; margin-left: 5px;">
                        üé§ Mikrofon Test
                    </button>
                </div>
            </div>
        </div>
        
        <div class="results hidden" id="results">
            <h2>üìä Benchmark Ergebnisse</h2>
            <div id="results-content"></div>
        </div>
    </div>

    <script>
        // API Configuration
        const API_BASE_URL = 'http://127.0.0.1:8001';
        
        // Global state
        let isListening = false;
        let recognition = null;
        let speechSynthesis = window.speechSynthesis;
        
        // Initialize Speech Recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'de-DE';
                recognition.continuous = false;
                recognition.interimResults = true;
                
                recognition.onstart = function() {
                    isListening = true;
                    document.getElementById('mic-button').classList.add('listening');
                    document.getElementById('voice-status-text').textContent = 'Ich h√∂re zu...';
                    document.getElementById('voice-feedback').textContent = 'Sprechen Sie jetzt...';
                };
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('voice-feedback').textContent = `Geh√∂rt: "${transcript}"`;
                    
                    if (event.results[0].isFinal) {
                        processVoiceCommand(transcript);
                    }
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    speak('Entschuldigung, ich konnte Sie nicht verstehen.');
                    resetVoiceUI();
                };
                
                recognition.onend = function() {
                    resetVoiceUI();
                };
                
                return true;
            }
            return false;
        }
        
        // Toggle Voice Recognition
        function toggleVoiceRecognition() {
            if (!recognition) {
                if (!initSpeechRecognition()) {
                    alert('Spracherkennung wird in diesem Browser nicht unterst√ºtzt.');
                    return;
                }
            }
            
            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }
        
        // Reset Voice UI
        function resetVoiceUI() {
            isListening = false;
            document.getElementById('mic-button').classList.remove('listening');
            document.getElementById('voice-status-text').textContent = 'Klicken Sie auf das Mikrofon';
        }
        
        // Text to Speech
        function speak(text) {
            if (speechSynthesis) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'de-DE';
                utterance.rate = 0.9;
                speechSynthesis.speak(utterance);
            }
        }
        
        // Process Voice Commands
        function processVoiceCommand(command) {
            const lowerCommand = command.toLowerCase();
            document.getElementById('voice-feedback').textContent = `Verarbeite: "${command}"`;
            
            if (lowerCommand.includes('matrix') || lowerCommand.includes('matrizen')) {
                speak('Matrix Benchmark wird gestartet...');
                runBenchmark('benchmark_matrix');
            } else if (lowerCommand.includes('quantum') || lowerCommand.includes('quanten')) {
                speak('Quantum Benchmark wird gestartet...');
                runBenchmark('benchmark_quantum');
            } else if (lowerCommand.includes('alle') || lowerCommand.includes('all')) {
                speak('Alle Benchmarks werden gestartet...');
                runBenchmark('benchmark_all');
            } else if (lowerCommand.includes('status') || lowerCommand.includes('zustand')) {
                speak('System-Status wird aktualisiert...');
                loadSystemStatus();
            } else if (lowerCommand.includes('hilfe') || lowerCommand.includes('help')) {
                speak('Verf√ºgbare Befehle: Matrix Benchmark, Quantum Benchmark, Alle Benchmarks, Status, oder Hilfe.');
            } else {
                speak(`Befehl "${command}" wurde nicht erkannt. Sagen Sie "Hilfe" f√ºr verf√ºgbare Befehle.`);
            }
        }
        
        // Load System Status
        async function loadSystemStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/`);
                const data = await response.json();
                
                document.getElementById('server-status').textContent = data.status || 'Unknown';
                document.getElementById('tools-count').textContent = data.tools_available || '0';
                
                console.log('System Status:', data);
            } catch (error) {
                console.error('Error loading system status:', error);
                document.getElementById('server-status').textContent = 'Error';
                document.getElementById('tools-count').textContent = 'Error';
            }
        }
        
        // Run Benchmark
        async function runBenchmark(toolName) {
            const button = event?.target;
            if (button) {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> L√§uft...';
            }
            
            try {
                const params = {
                    preset: 'small',
                    iterations: toolName === 'benchmark_quantum' ? 5 : 10
                };
                
                const response = await fetch(`${API_BASE_URL}/mcp`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tool: toolName,
                        params: params
                    })
                });
                
                const result = await response.json();
                displayResults(result);
                
                // Update last run
                document.getElementById('last-run').textContent = new Date().toLocaleTimeString('de-DE');
                
                // Enhanced voice feedback
                if (result.status === 'success') {
                    const apiResponse = result.result?.api_response || result.api_response;
                    if (apiResponse?.results) {
                        const results = apiResponse.results;

                        // Handle comprehensive benchmark results
                        if (results.overall_score !== undefined) {
                            const overallScore = smartPercentage(results.overall_score);
                            const totalTime = results.total_time || 0;
                            speak(`Umfassender Benchmark abgeschlossen. Gesamtbewertung: ${overallScore} Prozent. Ausf√ºhrungszeit: ${totalTime} Sekunden.`);
                        }
                        // Handle individual benchmark results
                        else if (results.throughput_ops_per_sec !== undefined || results.efficiency_score !== undefined) {
                            const throughput = Math.round(results.throughput_ops_per_sec || 0);
                            const efficiency = smartPercentage(results.efficiency_score);
                            speak(`Benchmark abgeschlossen. Durchsatz: ${throughput} Operationen pro Sekunde. Effizienz: ${efficiency} Prozent.`);
                        }
                        // Handle quantum benchmark results
                        else if (results.fidelity !== undefined) {
                            const fidelity = smartPercentage(results.fidelity);
                            const quantumVolume = results.quantum_volume || 0;
                            speak(`Quantum Benchmark abgeschlossen. Fidelity: ${fidelity} Prozent. Quantum Volume: ${quantumVolume}.`);
                        }
                        else {
                            speak('Benchmark erfolgreich abgeschlossen.');
                        }
                    } else {
                        speak('Benchmark erfolgreich abgeschlossen.');
                    }
                } else {
                    speak('Benchmark fehlgeschlagen.');
                }
                
            } catch (error) {
                console.error('Error running benchmark:', error);
                speak('Fehler beim Ausf√ºhren des Benchmarks.');
                displayResults({ error: error.message });
            } finally {
                if (button) {
                    button.disabled = false;
                    button.innerHTML = button.textContent.replace(' L√§uft...', '').replace('üîÑ', '') + ' starten';
                }
            }
        }
        
        // Enhanced Display Results - handles both individual and comprehensive benchmarks
        function displayResults(result) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');

            resultsDiv.classList.remove('hidden');

            if (result.error) {
                contentDiv.innerHTML = `
                    <div style="color: #e74c3c; padding: 15px; background: #fdf2f2; border-radius: 8px;">
                        <strong>‚ùå Fehler:</strong> ${result.error}
                    </div>
                `;
                return;
            }

            const apiResponse = result.result?.api_response || result.api_response;
            if (!apiResponse) {
                contentDiv.innerHTML = `
                    <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <strong>Benchmark-Ergebnis:</strong>
                        <pre style="margin-top: 10px; font-size: 0.9em; overflow-x: auto;">${JSON.stringify(result, null, 2)}</pre>
                    </div>
                `;
                return;
            }

            const results = apiResponse.results;
            const benchmarkId = apiResponse.benchmark_id || 'N/A';
            const status = apiResponse.status || result.status || 'unknown';

            // Check if this is a comprehensive benchmark (has overall_score)
            if (results?.overall_score !== undefined) {
                displayComprehensiveBenchmarkResults(results, benchmarkId, status, result);
            } else if (results?.throughput_ops_per_sec !== undefined || results?.total_time !== undefined) {
                displayIndividualBenchmarkResults(results, benchmarkId, status, result);
            } else {
                displayGenericResults(result, benchmarkId, status);
            }
        }

        // Smart percentage conversion - handles both decimal (0.0-1.0) and percentage (0-100) formats
        function smartPercentage(value) {
            if (value === null || value === undefined) return 0;
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return 0;

            // If value is between 0 and 1, it's likely a decimal (0.76 = 76%)
            if (numValue >= 0 && numValue <= 1) {
                return Math.round(numValue * 100);
            }
            // If value is greater than 1, it's likely already a percentage
            else if (numValue > 1 && numValue <= 100) {
                return Math.round(numValue);
            }
            // If value is greater than 100, it might be an inflated percentage, normalize it
            else if (numValue > 100) {
                return Math.round(numValue / 100);
            }
            return Math.round(numValue);
        }

        // Display comprehensive benchmark results (benchmark_all)
        function displayComprehensiveBenchmarkResults(results, benchmarkId, status, fullResult) {
            const contentDiv = document.getElementById('results-content');

            const overallScore = smartPercentage(results.overall_score);
            const totalTime = results.total_time || 'N/A';
            const componentScores = results.component_scores || {};
            const systemInfo = results.system_info || {};

            let componentScoresHtml = '';
            if (Object.keys(componentScores).length > 0) {
                componentScoresHtml = Object.entries(componentScores).map(([key, value]) => {
                    const percentage = smartPercentage(value);
                    const colorClass = percentage >= 80 ? '#e8f5e8' : percentage >= 60 ? '#fff3cd' : '#fdf2f2';
                    const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    return `
                        <div style="padding: 12px; background: ${colorClass}; border-radius: 8px;">
                            <strong>${displayName}:</strong><br>
                            ${percentage}%
                        </div>
                    `;
                }).join('');
            }

            let systemInfoHtml = '';
            if (Object.keys(systemInfo).length > 0) {
                systemInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <strong>üñ•Ô∏è System Information:</strong><br>
                        <div style="margin-top: 8px; font-size: 0.9em;">
                            ${Object.entries(systemInfo).map(([key, value]) =>
                                `<span style="display: inline-block; margin-right: 15px;"><strong>${key}:</strong> ${value}</span>`
                            ).join('<br>')}
                        </div>
                    </div>
                `;
            }

            contentDiv.innerHTML = `
                <div style="margin-bottom: 15px; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0; font-size: 1.5em;">üèÜ Comprehensive Benchmark Results</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Benchmark ID: ${benchmarkId} | Status: ${status}</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div style="padding: 15px; background: #e8f5e8; border-radius: 8px; text-align: center;">
                        <strong>üéØ Overall Score:</strong><br>
                        <span style="font-size: 2em; font-weight: bold; color: #27ae60;">${overallScore}%</span>
                    </div>
                    <div style="padding: 15px; background: #e8f4fd; border-radius: 8px; text-align: center;">
                        <strong>‚è±Ô∏è Total Time:</strong><br>
                        <span style="font-size: 1.5em; font-weight: bold; color: #3498db;">${totalTime}s</span>
                    </div>
                </div>

                ${componentScoresHtml ? `
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; color: #2c3e50;">üìä Component Scores:</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px;">
                            ${componentScoresHtml}
                        </div>
                    </div>
                ` : ''}

                ${systemInfoHtml}

                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; padding: 10px; background: #f8f9fa; border-radius: 8px; font-weight: bold;">
                        üîç View Full Results (Click to expand)
                    </summary>
                    <pre style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 0.8em; overflow-x: auto; max-height: 400px; overflow-y: auto;">${JSON.stringify(fullResult, null, 2)}</pre>
                </details>
            `;
        }

        // Display individual benchmark results (benchmark_matrix, benchmark_quantum)
        function displayIndividualBenchmarkResults(results, benchmarkId, status, fullResult) {
            const contentDiv = document.getElementById('results-content');

            const totalTime = results.total_time || 'N/A';
            const throughput = Math.round(results.throughput_ops_per_sec || 0);
            const efficiency = smartPercentage(results.efficiency_score);
            const memoryUsage = results.memory_usage_mb || 'N/A';

            // Handle matrix-specific results
            let specificResultsHtml = '';
            if (results.matrix_results && Array.isArray(results.matrix_results)) {
                specificResultsHtml = `
                    <div style="margin-top: 15px;">
                        <h4 style="margin-bottom: 10px; color: #2c3e50;">üî¢ Matrix Results:</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                            ${results.matrix_results.map(matrix => `
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                                    <strong>${matrix.size}x${matrix.size}</strong><br>
                                    <small>${matrix.time_ms?.toFixed(2) || 'N/A'}ms</small><br>
                                    <small>${(matrix.flops / 1e9)?.toFixed(1) || 'N/A'} GFLOPS</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Handle quantum-specific results
            if (results.circuit_depth !== undefined) {
                specificResultsHtml = `
                    <div style="margin-top: 15px;">
                        <h4 style="margin-bottom: 10px; color: #2c3e50;">‚öõÔ∏è Quantum Results:</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                            <div style="padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                                <strong>Circuit Depth:</strong><br>${results.circuit_depth || 'N/A'}
                            </div>
                            <div style="padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                                <strong>Qubits:</strong><br>${results.qubit_count || 'N/A'}
                            </div>
                            <div style="padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                                <strong>Fidelity:</strong><br>${smartPercentage(results.fidelity)}%
                            </div>
                            <div style="padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                                <strong>Quantum Volume:</strong><br>${results.quantum_volume || 'N/A'}
                            </div>
                        </div>
                    </div>
                `;
            }

            contentDiv.innerHTML = `
                <div style="margin-bottom: 15px; padding: 15px; background: linear-gradient(45deg, #3498db, #2980b9); color: white; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0; font-size: 1.3em;">‚úÖ Benchmark Completed</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">ID: ${benchmarkId} | Status: ${status}</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div style="padding: 15px; background: #e8f5e8; border-radius: 8px; text-align: center;">
                        <strong>‚è±Ô∏è Total Time:</strong><br>
                        <span style="font-size: 1.5em; font-weight: bold; color: #27ae60;">${totalTime}s</span>
                    </div>
                    <div style="padding: 15px; background: #e8f4fd; border-radius: 8px; text-align: center;">
                        <strong>üöÄ Throughput:</strong><br>
                        <span style="font-size: 1.5em; font-weight: bold; color: #3498db;">${throughput} ops/sec</span>
                    </div>
                    <div style="padding: 15px; background: #fff3cd; border-radius: 8px; text-align: center;">
                        <strong>‚ö° Efficiency:</strong><br>
                        <span style="font-size: 1.5em; font-weight: bold; color: #f39c12;">${efficiency}%</span>
                    </div>
                    <div style="padding: 15px; background: #f8d7da; border-radius: 8px; text-align: center;">
                        <strong>üíæ Memory:</strong><br>
                        <span style="font-size: 1.5em; font-weight: bold; color: #e74c3c;">${memoryUsage} MB</span>
                    </div>
                </div>

                ${specificResultsHtml}

                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; padding: 10px; background: #f8f9fa; border-radius: 8px; font-weight: bold;">
                        üîç View Full Results (Click to expand)
                    </summary>
                    <pre style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 0.8em; overflow-x: auto; max-height: 400px; overflow-y: auto;">${JSON.stringify(fullResult, null, 2)}</pre>
                </details>
            `;
        }

        // Display generic results (fallback)
        function displayGenericResults(result, benchmarkId, status) {
            const contentDiv = document.getElementById('results-content');

            contentDiv.innerHTML = `
                <div style="margin-bottom: 15px; padding: 15px; background: #6c757d; color: white; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0; font-size: 1.3em;">üìã Benchmark Result</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">ID: ${benchmarkId} | Status: ${status}</p>
                </div>

                <div style="padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <strong>Raw Result:</strong>
                    <pre style="margin-top: 10px; font-size: 0.9em; overflow-x: auto; max-height: 400px; overflow-y: auto;">${JSON.stringify(result, null, 2)}</pre>
                </div>
            `;
        }

        // Whisper Voice Control Variables
        let whisperRecording = false;
        let whisperMediaRecorder = null;
        let whisperAudioChunks = [];
        const WHISPER_SERVICE_URL = 'http://127.0.0.1:8003';

        // Alternative Web Audio API Variables
        let audioContext = null;
        let mediaStreamSource = null;
        let processor = null;
        let audioBuffer = [];
        let recordingStream = null;

        // D√∂ner Bestellsystem Variables
        let currentOrder = [];
        let orderTotal = 0;

        // D√∂ner Produkte
        const doenerProducts = [
            {
                id: 'schueler_doener',
                name: 'Sch√ºler D√∂ner',
                description: 'Sch√ºler D√∂ner mit D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√∂nerfleisch', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 7.00
            },
            {
                id: 'doener',
                name: 'D√∂ner',
                description: 'D√∂ner mit D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√∂nerfleisch', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 9.00
            },
            {
                id: 'vegetarischer_doener',
                name: 'Vegetarischer D√∂ner',
                description: 'Vegetarischer D√∂ner mit K√§se, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['K√§se', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 7.00
            },
            {
                id: 'yufka_doener',
                name: 'Yufka D√∂ner',
                description: 'Yufka D√∂ner mit D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√∂nerfleisch', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 10.00
            },
            {
                id: 'jumbo_doener',
                name: 'Jumbo D√∂ner',
                description: 'Jumbo D√∂ner mit D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√∂nerfleisch', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 11.00
            },
            {
                id: 'doener_teller',
                name: 'D√∂ner-Teller',
                description: 'D√∂ner-Teller mit Pommes frites, D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√∂nerfleisch', 'Pommes frites', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 12.00
            },
            {
                id: 'lahmacun_klassisch',
                name: 'Lahmacun Klassisch',
                description: 'Lahmacun Klassisch ohne Salat',
                baseIngredients: ['D√ºnner Teig', 'Hackfleisch', 'Tomaten', 'Zwiebeln', 'Gew√ºrze'],
                price: 6.00
            },
            {
                id: 'lahmacun_doener',
                name: 'Lahmacun mit D√∂nerfleisch',
                description: 'Lahmacun mit D√∂nerfleisch - mit D√∂nerfleisch, Eisbergsalat, Tomaten, Gurken, Zwiebeln, Rotkraut, Mais und einer Sauce Ihrer Wahl',
                baseIngredients: ['D√ºnner Teig', 'Hackfleisch', 'D√∂nerfleisch', 'Eisbergsalat', 'Tomaten', 'Gurken', 'Zwiebeln', 'Rotkraut', 'Mais', 'Sauce nach Wahl'],
                price: 10.00
            }
        ];

        // Extra Zutaten
        const extraIngredients = [
            { name: 'Extra Fleisch', price: 2.00 },
            { name: 'Extra K√§se', price: 1.50 },
            { name: 'Jalape√±os', price: 0.50 },
            { name: 'Peperoni', price: 0.50 },
            { name: 'Oliven', price: 0.50 },
            { name: 'Feta-K√§se', price: 1.00 },
            { name: 'Avocado', price: 1.50 },
            { name: 'Extra Sauce', price: 0.50 }
        ];

        // Toggle Whisper Recording
        async function toggleWhisperRecording() {
            const button = document.getElementById('whisper-voice-button');
            const status = document.getElementById('whisper-status');

            if (!whisperRecording) {
                try {
                    // Enhanced microphone access with constraints
                    const constraints = {
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100,
                            channelCount: 1
                        }
                    };

                    console.log('üé§ Requesting microphone access...');
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);

                    // Check if we got audio tracks
                    const audioTracks = stream.getAudioTracks();
                    console.log(`üé§ Audio tracks: ${audioTracks.length}`);
                    if (audioTracks.length > 0) {
                        console.log(`üé§ Using: ${audioTracks[0].label}`);
                    }

                    // Try different audio formats for better compatibility
                    let mimeType = '';
                    const supportedTypes = [
                        'audio/wav',
                        'audio/webm;codecs=pcm',
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4',
                        'audio/ogg;codecs=opus'
                    ];

                    for (const type of supportedTypes) {
                        if (MediaRecorder.isTypeSupported(type)) {
                            mimeType = type;
                            break;
                        }
                    }

                    console.log(`üé§ Using MIME type: ${mimeType || 'default'}`);
                    console.log(`üé§ Supported types: ${supportedTypes.filter(t => MediaRecorder.isTypeSupported(t)).join(', ')}`);

                    const recorderOptions = mimeType ? {
                        mimeType: mimeType,
                        audioBitsPerSecond: 128000
                    } : {
                        audioBitsPerSecond: 128000
                    };

                    whisperMediaRecorder = new MediaRecorder(stream, recorderOptions);
                    whisperAudioChunks = [];

                    whisperMediaRecorder.ondataavailable = (event) => {
                        console.log(`üé§ Audio chunk: ${event.data.size} bytes, type: ${event.data.type}`);
                        if (event.data.size > 0) {
                            whisperAudioChunks.push(event.data);
                            console.log(`üé§ Total chunks collected: ${whisperAudioChunks.length}`);
                        } else {
                            console.log('‚ö†Ô∏è Empty audio chunk received');
                        }
                    };

                    whisperMediaRecorder.onstop = async () => {
                        console.log(`üé§ Audio chunks collected: ${whisperAudioChunks.length}`);

                        // Try different blob types for better compatibility
                        let audioBlob;
                        if (whisperAudioChunks.length > 0) {
                            // Try the original MIME type first
                            audioBlob = new Blob(whisperAudioChunks, { type: mimeType || 'audio/webm' });
                            console.log(`üé§ Created blob: ${audioBlob.size} bytes, type: ${audioBlob.type}`);

                            // If blob is too small, try without MIME type
                            if (audioBlob.size < 1000) {
                                audioBlob = new Blob(whisperAudioChunks);
                                console.log(`üé§ Fallback blob: ${audioBlob.size} bytes, type: ${audioBlob.type}`);
                            }
                        } else {
                            console.log('‚ùå No audio chunks collected!');
                            document.getElementById('whisper-status').textContent = '‚ùå Keine Audio-Daten aufgenommen';
                            return;
                        }

                        await processWhisperAudio(audioBlob);
                    };

                    whisperMediaRecorder.start(100); // Collect data every 100ms for better quality
                    whisperRecording = true;

                    button.textContent = 'üõë Aufnahme stoppen';
                    button.style.background = 'rgba(255,255,255,0.3)';
                    status.textContent = 'üé§ Aufnahme l√§uft... Sprechen Sie LAUT und DEUTLICH!';

                    console.log('üé§ Whisper-Aufnahme gestartet');
                    speak('Aufnahme gestartet. Sprechen Sie jetzt.');

                } catch (error) {
                    console.error('Fehler beim Starten der Aufnahme:', error);
                    status.textContent = `Fehler: ${error.message}`;
                    speak('Mikrofon-Zugriff fehlgeschlagen. Bitte Berechtigung erteilen.');
                }
            } else {
                // Stop recording
                if (whisperMediaRecorder && whisperMediaRecorder.state === 'recording') {
                    whisperMediaRecorder.stop();
                    whisperMediaRecorder.stream.getTracks().forEach(track => track.stop());
                }

                whisperRecording = false;
                button.textContent = 'üé§ Whisper Aufnahme';
                button.style.background = 'rgba(255,255,255,0.2)';
                status.textContent = '‚è≥ Verarbeite Audio mit Whisper...';

                console.log('üõë Whisper-Aufnahme gestoppt - Verarbeitung...');
            }
        }

        // Process audio with Whisper service
        async function processWhisperAudio(audioBlob) {
            const status = document.getElementById('whisper-status');
            const startTime = Date.now();

            try {
                // Debug audio blob
                console.log(`üé§ Audio Blob Info: Size=${audioBlob.size} bytes, Type=${audioBlob.type}`);

                if (audioBlob.size < 1000) {
                    throw new Error(`Audio zu kurz (${audioBlob.size} bytes). Sprechen Sie l√§nger und lauter.`);
                }

                status.textContent = 'üîÑ Sende Audio an Whisper-Service...';

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.wav');
                formData.append('language', 'de');

                const response = await fetch(`${WHISPER_SERVICE_URL}/api/whisper`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const result = await response.json();
                const processingTime = Date.now() - startTime;

                // Enhanced logging
                console.log(`üé§ Audio verarbeitet: ${audioBlob.size} bytes`);
                console.log(`üìù Transkript: "${result.transcript}"`);
                console.log(`üéØ Intent: ${result.detected_intent}`);
                console.log(`‚ö° Action: ${result.mapped_action}`);
                console.log(`‚è±Ô∏è Verarbeitungszeit: ${processingTime}ms`);
                console.log(`üéØ Confidence: ${Math.round(result.confidence * 100)}%`);

                // Check for empty transcript
                if (!result.transcript || result.transcript.trim() === '') {
                    status.textContent = '‚ö†Ô∏è Kein Text erkannt. Sprechen Sie lauter und deutlicher.';
                    speak('Kein Text erkannt. Bitte sprechen Sie lauter und deutlicher.');

                    setTimeout(() => {
                        status.textContent = 'Bereit f√ºr Whisper-Transkription';
                    }, 4000);
                    return;
                }

                status.textContent = `‚úÖ "${result.transcript}" (${result.detected_intent})`;

                // Execute the mapped action
                await executeWhisperAction(result);

            } catch (error) {
                console.error('Whisper-Verarbeitungsfehler:', error);
                status.textContent = `‚ùå ${error.message}`;
                speak(`Fehler: ${error.message}`);

                // Reset status after delay
                setTimeout(() => {
                    status.textContent = 'Bereit f√ºr Whisper-Transkription';
                }, 5000);
            }
        }

        // Execute action based on Whisper result
        async function executeWhisperAction(whisperResult) {
            const { transcript, detected_intent, mapped_action, confidence } = whisperResult;

            console.log(`üöÄ F√ºhre Aktion aus: ${mapped_action}`);

            // Provide voice feedback
            speak(`${transcript} erkannt. F√ºhre ${detected_intent} aus.`);

            switch (mapped_action) {
                case 'benchmark_matrix':
                case 'benchmark_matrix_quick':
                    await runBenchmark('benchmark_matrix');
                    break;

                case 'benchmark_quantum':
                case 'benchmark_quantum_quick':
                    await runBenchmark('benchmark_quantum');
                    break;

                case 'benchmark_all':
                case 'benchmark_all_quick':
                    await runBenchmark('benchmark_all');
                    break;

                case 'get_status':
                    await loadSystemStatus();
                    speak('System-Status wird angezeigt.');
                    break;

                case 'show_help':
                    speak('Verf√ºgbare Befehle: Matrix Benchmark schnell, Quantum Benchmark, Alle Benchmarks, Status, oder Hilfe.');
                    break;

                default:
                    speak(`Befehl "${transcript}" wurde erkannt, aber keine Aktion zugeordnet.`);
                    console.log(`‚ö†Ô∏è Keine Aktion f√ºr: ${mapped_action}`);
            }

            // Reset status after a delay
            setTimeout(() => {
                document.getElementById('whisper-status').textContent = 'Bereit f√ºr Whisper-Transkription';
            }, 5000);
        }

        // Process text command directly
        async function processTextCommand() {
            const input = document.getElementById('voice-text-input');
            const command = input.value.trim().toLowerCase();
            const status = document.getElementById('whisper-status');

            if (!command) {
                status.textContent = '‚ö†Ô∏è Bitte geben Sie einen Befehl ein';
                return;
            }

            status.textContent = `üîÑ Verarbeite Text-Befehl: "${command}"`;

            // Send to Whisper service for intent mapping
            try {
                const response = await fetch(`${WHISPER_SERVICE_URL}/api/whisper/intents`);
                if (response.ok) {
                    // Create a fake result and process it
                    const fakeResult = {
                        transcript: command,
                        detected_intent: mapTextToIntent(command),
                        mapped_action: mapTextToAction(command),
                        confidence: 1.0
                    };

                    console.log(`üìù Text-Befehl: ${JSON.stringify(fakeResult)}`);
                    await executeWhisperAction(fakeResult);

                    // Clear input
                    input.value = '';
                } else {
                    throw new Error('Service nicht verf√ºgbar');
                }
            } catch (error) {
                // Fallback: direct mapping
                const fakeResult = {
                    transcript: command,
                    detected_intent: mapTextToIntent(command),
                    mapped_action: mapTextToAction(command),
                    confidence: 1.0
                };

                console.log(`üìù Text-Befehl (Fallback): ${JSON.stringify(fakeResult)}`);
                await executeWhisperAction(fakeResult);
                input.value = '';
            }
        }

        // Simple text to intent mapping
        function mapTextToIntent(text) {
            if (text.includes('matrix')) return 'matrix';
            if (text.includes('quantum')) return 'quantum';
            if (text.includes('alle') || text.includes('all')) return 'all';
            if (text.includes('status')) return 'status';
            if (text.includes('hilfe') || text.includes('help')) return 'help';
            if (text.includes('test')) return 'test';
            return 'unknown';
        }

        // Simple text to action mapping
        function mapTextToAction(text) {
            if (text.includes('matrix')) return 'benchmark_matrix';
            if (text.includes('quantum')) return 'benchmark_quantum';
            if (text.includes('alle') || text.includes('all')) return 'benchmark_all';
            if (text.includes('status')) return 'get_status';
            if (text.includes('hilfe') || text.includes('help')) return 'show_help';
            if (text.includes('test')) return 'test_response';
            return 'no_action';
        }

        // Simulate Whisper command (for testing)
        async function simulateWhisperCommand(command) {
            const status = document.getElementById('whisper-status');

            status.textContent = `üîÑ Schnell-Befehl: "${command}"`;

            // Create fake Whisper result
            const fakeResult = {
                transcript: command,
                detected_intent: mapTextToIntent(command),
                mapped_action: mapTextToAction(command),
                confidence: 0.95
            };

            console.log(`‚ö° Schnell-Befehl: ${JSON.stringify(fakeResult)}`);

            // Execute the action
            await executeWhisperAction(fakeResult);
        }

        // Test microphone access and recording
        async function testMicrophone() {
            const status = document.getElementById('whisper-status');
            status.textContent = 'üé§ Teste Mikrofon-Zugriff...';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });

                const audioTracks = stream.getAudioTracks();
                console.log(`üé§ Mikrofon gefunden: ${audioTracks[0].label}`);
                console.log(`üé§ Settings:`, audioTracks[0].getSettings());

                // Test recording for 2 seconds
                const recorder = new MediaRecorder(stream);
                const chunks = [];

                recorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                    console.log(`üé§ Test chunk: ${event.data.size} bytes`);
                };

                recorder.onstop = () => {
                    const blob = new Blob(chunks);
                    console.log(`üé§ Test recording: ${blob.size} bytes total`);
                    status.textContent = `‚úÖ Mikrofon OK: ${blob.size} bytes aufgenommen`;

                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };

                recorder.start(100);
                status.textContent = 'üé§ Aufnahme f√ºr 2 Sekunden... Sprechen Sie!';

                setTimeout(() => {
                    recorder.stop();
                }, 2000);

            } catch (error) {
                console.error('Mikrofon-Test Fehler:', error);
                status.textContent = `‚ùå Mikrofon-Fehler: ${error.message}`;
            }
        }

        // Test with JFK audio file (server-side test)
        async function testWithJFKAudio() {
            const status = document.getElementById('whisper-status');
            status.textContent = 'üéµ Teste mit JFK Audio-Datei...';

            try {
                const response = await fetch(`${WHISPER_SERVICE_URL}/api/whisper/test-jfk`, {
                    method: 'POST'
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('üéµ JFK Test Result:', result);

                    status.textContent = `‚úÖ JFK Test: "${result.transcript}"`;

                    // Show the result for a few seconds
                    setTimeout(() => {
                        status.textContent = 'Bereit f√ºr Sprach- oder Text-Eingabe';
                    }, 5000);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('JFK Test failed:', error);
                status.textContent = `‚ùå JFK Test fehlgeschlagen: ${error.message}`;

                setTimeout(() => {
                    status.textContent = 'Bereit f√ºr Sprach- oder Text-Eingabe';
                }, 3000);
            }
        }

        // Process uploaded audio file
        async function processAudioFile(input) {
            const status = document.getElementById('whisper-status');

            if (!input.files || input.files.length === 0) {
                status.textContent = '‚ùå Keine Datei ausgew√§hlt';
                return;
            }

            const file = input.files[0];
            console.log(`üìÅ Audio file: ${file.name}, size: ${file.size} bytes, type: ${file.type}`);

            status.textContent = `üîÑ Verarbeite Audio-Datei: ${file.name}`;

            try {
                const formData = new FormData();
                formData.append('audio', file);
                formData.append('language', 'de');

                const response = await fetch(`${WHISPER_SERVICE_URL}/api/whisper`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                console.log('üìÅ File processing result:', result);

                status.textContent = `‚úÖ "${result.transcript}" (${result.detected_intent})`;

                // Execute the mapped action
                await executeWhisperAction(result);

            } catch (error) {
                console.error('Audio file processing error:', error);
                status.textContent = `‚ùå Fehler: ${error.message}`;

                setTimeout(() => {
                    status.textContent = 'Bereit f√ºr Sprach- oder Text-Eingabe';
                }, 3000);
            }
        }

        // Check Whisper service availability
        async function checkWhisperService() {
            try {
                const response = await fetch(`${WHISPER_SERVICE_URL}/`);
                const data = await response.json();

                if (data.whisper_available && data.model_available) {
                    console.log('‚úÖ Whisper-Service verf√ºgbar');
                    document.getElementById('whisper-status').textContent = 'Whisper-Service bereit';
                } else {
                    console.log('‚ö†Ô∏è Whisper-Service nicht vollst√§ndig verf√ºgbar');
                    document.getElementById('whisper-status').textContent = 'Whisper-Service nicht bereit';
                }
            } catch (error) {
                console.log('‚ùå Whisper-Service nicht erreichbar');
                document.getElementById('whisper-status').textContent = 'Whisper-Service offline';
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadSystemStatus();
            initSpeechRecognition();
            checkWhisperService(); // Check Whisper service

            // Add Enter key support for text input
            const textInput = document.getElementById('voice-text-input');
            if (textInput) {
                textInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        processTextCommand();
                    }
                });
            }

            // Auto-refresh status every 30 seconds
            setInterval(loadSystemStatus, 30000);
        });
    </script>
</body>
</html>
