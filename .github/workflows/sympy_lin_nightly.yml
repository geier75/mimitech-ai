name: SymPy Linear Solver Nightly

on:
  schedule:
    - cron: '15 2 * * *'   # nightly at 02:15 UTC
    - cron: '45 3 * * 0'   # weekly (Sunday) at 03:45 UTC
  workflow_dispatch:

jobs:
  nightly:
    runs-on: ubuntu-latest
    env:
      # Optional: provide the real NPZ via repository secret
      UK165_NPZ_URL: ${{ secrets.UK165_NPZ_URL }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install minimal deps
        run: |
          python -m pip install --upgrade pip
          pip install sympy numpy

      - name: Run benchmark (real 165×165 via URL with offline fallback)
        id: run_bench
        env:
          UK165_NPZ_URL: ${{ secrets.UK165_NPZ_URL }}
          BENCH_SIZE: "165"
        run: |
          set -euo pipefail
          export PYTHONHASHSEED=0
          export OUT_DIR="benchmark_output_$(date +%Y%m%d_%H%M%S)"
          mkdir -p "$OUT_DIR"
          
          python - <<'PY'
          import os, json, time, random, sys, io, hashlib
          import numpy as np
          import sympy as sp
          from urllib.request import urlopen, Request
          from pathlib import Path
          
          URL = os.getenv("UK165_NPZ_URL", "").strip()
          N   = int(os.getenv("BENCH_SIZE", "165"))
          PATH = "bench_matrix.bin"
          
          def download(u, dst, retries=3, timeout=15):
              for i in range(1, retries+1):
                  try:
                      req = Request(u, headers={"User-Agent":"ci"})
                      with urlopen(req, timeout=timeout) as r:
                          open(dst,"wb").write(r.read()); return True
                  except Exception as e:
                      print(f"[warn] download attempt {i}/{retries} failed: {e}")
                      time.sleep(2*i)
              return False
          
          ok = False
          if URL:
              ok = download(URL, PATH)
              if ok: print(f"[ok] downloaded matrix from {URL}")
          
          if ok:
              buf = open(PATH,"rb").read()
              try:
                  # npz path
                  with np.load(io.BytesIO(buf)) as z:
                      A = sp.Matrix(z["A"].tolist())
                      b = sp.Matrix(z["b"].tolist())
                  source = "real-npz"
              except Exception:
                  # json path
                  d = json.loads(buf.decode("utf-8"))
                  A = sp.Matrix(d["A"]); b = sp.Matrix(d["b"])
                  source = "real-json"
          else:
              print("[info] falling back to synthetic matrix")
              random.seed(42)
              A = sp.Matrix([[random.random() for _ in range(N)] for __ in range(N)])
              b = sp.Matrix([random.random() for _ in range(N)])
              source = "synthetic"
          
          t0=time.time(); x = A.LUsolve(b); dt=time.time()-t0
          
          # residual & stable hash
          r = A*x - b
          r2 = float(sp.sqrt((r.T*r)[0]))
          quant = np.asarray([float(v) for v in x], dtype=np.float64)
          qbytes = np.round(quant, 12).tobytes()
          sha = hashlib.sha256(qbytes).hexdigest()
          
          metrics = {
            "n": int(N),
            "method": "LUsolve",
            "solve_sec": float(round(dt, 6)),
            "residual_l2": r2,
            "solution_sha256": sha,
            "source": source
          }
          
          # Save results to both output directory and metrics file
          out_dir = os.getenv("OUT_DIR", ".")
          result_file = Path(out_dir) / "benchmark_result.json"
          result_file.write_text(json.dumps(metrics, indent=2))
          
          # Write metrics file for gates step
          open("lin_solve_metrics.json","w").write(json.dumps(metrics, indent=2))
          
          print(json.dumps(metrics, indent=2))
          print(f"::set-output name=json_path::{result_file}")
          print(f"::set-output name=out_dir::{out_dir}")
          print(f"::set-output name=used_demo::{0 if 'real' in source else 1}")
          PY
          echo "OUT_DIR=$OUT_DIR" >> "$GITHUB_ENV"
          JSON_PATH="$OUT_DIR/benchmark_result.json"
          echo "JSON_PATH=$JSON_PATH" >> "$GITHUB_ENV"

      - name: Gates (residual, time, delta)
        run: |
          python - <<'PY'
          import json, sys, pathlib, math, os, time
          m = json.loads(pathlib.Path("lin_solve_metrics.json").read_text(encoding="utf-8"))
          errors = []

          # Hard gates (Nightly)
          if m.get("residual_l2", 1e9) > 1e-8:
              errors.append(f"residual_l2 too high: {m['residual_l2']:.3e} > 1e-8")
          if m.get("solve_sec", 1e9) > 120:
              errors.append(f"solve_sec too slow: {m['solve_sec']:.3f}s > 120s budget (nightly)")

          # Delta-Gate vs "last green" (optional: lege Datei im Repo ab)
          last_path = pathlib.Path("bench/lin_solve_last_green.json")
          if last_path.exists():
              last = json.loads(last_path.read_text(encoding="utf-8"))
              if m["solve_sec"] > last["solve_sec"] * 1.15:
                  errors.append(f"delta gate: {m['solve_sec']:.3f}s > +15% vs last green {last['solve_sec']:.3f}s")
          else:
              print("[info] no last_green available — delta gate skipped")

          if errors:
              print("GATES FAIL:\n - " + "\n - ".join(errors))
              sys.exit(1)
          print("GATES PASS")
          print(f"Performance: {m['solve_sec']:.3f}s, residual: {m['residual_l2']:.3e}")
          PY

      - name: Upload lin-solve metrics
        uses: actions/upload-artifact@v4
        with:
          name: sympy_lin_metrics
          path: lin_solve_metrics.json
          retention-days: 14

      - name: Upload results artifact (JSON + manifests)
        uses: actions/upload-artifact@v4
        with:
          name: sympy_lin_results
          path: ${{ steps.run_bench.outputs.out_dir }}
          if-no-files-found: error
