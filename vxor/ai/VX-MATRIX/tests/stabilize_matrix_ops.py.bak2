#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""VX-MATRIX Numerische Stabilisierung

Dieses Tool identifiziert und behebt numerische Stabilitätsprobleme in Matrix-Operationen.
ZTM-konform für MISO Ultimate.

Verwendung: python stabilize_matrix_ops.py --mode=fix --verbosity=debug --threshold=1e-8
"""

import argparse
import sys
import os
import time
import numpy as np
import logging
import json
from datetime import datetime
from scipy import linalg
import warnings

# Pfade für den Import konfigurieren
script_dir = os.path.dirname(os.path.abspath(__file__))
root_dir = os.path.dirname(script_dir)
sys.path.append(root_dir)

# VX-MATRIX-Module importieren
from core.matrix_core import MatrixCore, ztm_log, TensorType

# Konstanten
EPSILON = np.finfo(float).eps
LOGS_DIR = os.path.join(root_dir, 'logs')
FIXES_DIR = os.path.join(root_dir, 'optimizers', 'fixes')

# Verzeichnisse erstellen, falls sie nicht existieren
os.makedirs(LOGS_DIR, exist_ok=True)
os.makedirs(FIXES_DIR, exist_ok=True)

# Logger-Konfiguration
def setup_logger(level):
    """Konfiguriert den Logger basierend auf dem angegebenen Verbosity-Level."""
    level_map = {
        "silent": logging.ERROR,
        "info": logging.INFO,
        "debug": logging.DEBUG
    }
    log_level = level_map.get(level, logging.INFO)
    
    # Hauptlogger konfigurieren
    logger = logging.getLogger("vx_matrix_stabilizer")
    logger.setLevel(log_level)
    
    # Console-Handler hinzufügen
    console_handler = logging.StreamHandler()
    console_handler.setLevel(log_level)
    console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)
    
    # Datei-Handler hinzufügen
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(LOGS_DIR, f"stabilize_run_{timestamp}.log")
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(log_level)
    file_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_formatter)
    
    # Handler hinzufügen
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger, log_file


class MatrixStabilizer:
    """Werkzeug zur Identifikation und Behebung numerischer Stabilitätsprobleme in Matrix-Operationen."""
    
    def __init__(self, mode="analyze", verbosity="info", threshold=1e-8):
        """
        Initialisiert den MatrixStabilizer.
        
        Args:
            mode (str): Betriebsmodus ('analyze' oder 'fix')
            verbosity (str): Log-Level ('silent', 'info', 'debug')
            threshold (float): Schwellenwert für numerische Stabilität
        """
        self.mode = mode
        self.threshold = threshold
        self.logger, self.log_file = setup_logger(verbosity)
        
        # Matrix-Core-Instanz
        self.matrix_core = MatrixCore()
        
        # Statistiken
        self.stats = {
            "tested_functions": 0,
            "identified_issues": 0,
            "fixed_issues": 0,
            "generated_patches": 0,
            "runtime": 0,
            "details": {}
        }
        
        self.logger.info(f"MatrixStabilizer initialisiert im {mode.upper()}-Modus mit Schwellenwert {threshold}")
        
    def generate_test_matrices(self, sizes=[10, 50, 100, 200, 500], condition_numbers=[1e2, 1e4, 1e6, 1e8]):
        """
        Erzeugt eine Sammlung von Test-Matrizen mit verschiedenen Eigenschaften.
        
        Returns:
            dict: Sammlung von Test-Matrizen
        """
        self.logger.info("Generiere Testmatrizen...")
        
        test_matrices = {
            "random": {},
            "spd": {},
            "ill_conditioned": {},
            "edge_cases": {}
        }
        
        # Zufallsmatrizen verschiedener Größen
        for size in sizes:
            test_matrices["random"][size] = self._generate_stable_random_matrix(size)
            self.logger.debug(f"Zufallsmatrix {size}x{size} erzeugt")
        
        # SPD-Matrizen verschiedener Größen und Konditionszahlen
        for size in sizes:
            test_matrices["spd"][size] = {}
            for cond in condition_numbers:
                test_matrices["spd"][size][cond] = self._generate_spd_matrix(size, cond)
                self.logger.debug(f"SPD-Matrix {size}x{size} mit κ={cond:.1e} erzeugt")
        
        # Schlecht konditionierte Matrizen
        for size in sizes:
            test_matrices["ill_conditioned"][size] = {}
            for cond in condition_numbers:
                test_matrices["ill_conditioned"][size][cond] = self._generate_ill_conditioned_matrix(size, cond)
                self.logger.debug(f"Schlecht konditionierte Matrix {size}x{size} mit κ={cond:.1e} erzeugt")
        
        # Spezielle Testfälle
        test_matrices["edge_cases"] = {
            "zeros": np.zeros((100, 100)),
            "ones": np.ones((100, 100)),
            "identity": np.eye(100),
            "small_values": np.random.rand(100, 100) * 1e-10,
            "large_values": np.random.rand(100, 100) * 1e10,
            "mixed_scale": np.vstack([
                np.hstack([np.random.rand(50, 50) * 1e-8, np.random.rand(50, 50) * 1e8]),
                np.hstack([np.random.rand(50, 50) * 1e8, np.random.rand(50, 50) * 1e-8])
            ])
        }
        
        self.logger.info(f"Testmatrizen erzeugt: {len(sizes)} Größen, {len(condition_numbers)} Konditionszahlen, {len(test_matrices['edge_cases'])} Spezialfälle")
        return test_matrices
    
    def _generate_stable_random_matrix(self, size):
        """Erzeugt eine stabile Zufallsmatrix."""
        A = np.random.randn(size, size)
        scale_factor = np.max(np.abs(A)) + EPSILON
        A_scaled = A / scale_factor * 10.0
        A_safe = np.where(np.abs(A_scaled) < EPSILON * 10, np.sign(A_scaled) * EPSILON * 10, A_scaled)
        return A_safe

    def _generate_spd_matrix(self, size, condition_number):
        """Erzeugt eine symmetrisch positiv-definite Matrix mit stabilen Werten."""
        A = np.random.randn(size, size)
        A_safe = np.where(np.abs(A) < EPSILON * 10, np.sign(A) * EPSILON * 10, A)
        spd = A_safe @ A_safe.T
        eigvals, eigvecs = np.linalg.eigh(spd)
        smallest = max(np.min(eigvals), EPSILON * 100)
        eigvals_new = np.linspace(smallest * condition_number, smallest, size)
        spd_conditioned = eigvecs @ np.diag(eigvals_new) @ eigvecs.T
        return spd_conditioned

    def _generate_ill_conditioned_matrix(self, size, condition_number):
        """Erzeugt eine schlecht konditionierte Matrix, die aber numerisch stabil ist."""
        # Erzeuge orthogonale Matrix über QR-Zerlegung
        A = np.random.randn(size, size)
        Q, _ = np.linalg.qr(A)
        
        # Erzeuge Diagonalmatrix mit abnehmenden Singulärwerten, aber sicher gegen Null
        singular_values = np.logspace(np.log10(condition_number), 0, size)
        smallest_sv = max(singular_values[-1], EPSILON * 100)
        singular_values = np.linspace(smallest_sv * condition_number, smallest_sv, size)
        
        # Kombiniere zu Matrix mit spezifischer Konditionszahl
        return Q @ np.diag(singular_values) @ Q.T
    
    def analyze_matrix_multiply(self):
        """Analysiert die Matrixmultiplikation auf numerische Stabilitätsprobleme."""
        self.logger.info("Analysiere Matrixmultiplikation...")
        test_matrices = self.generate_test_matrices()
        issues = []
        
        # Teste mit Zufallsmatrizen
        for size, matrix_a in test_matrices["random"].items():
            matrix_b = self._generate_stable_random_matrix(size)
            
            try:
                # Original-Implementierung testen
                self.logger.debug(f"Teste Originalmultiplikation mit {size}x{size} Matrix")
                original_result = self.matrix_core.matrix_multiply(matrix_a, matrix_b)
                
                # NumPy-Referenz
                np_result = np.matmul(matrix_a, matrix_b)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "matrix_size": size,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
                # Unterschied zu NumPy-Referenz
                error = np.max(np.abs(original_result - np_result))
                if error > self.threshold:
                    error_msg = f"Großer Fehler ({error:.2e}) vs. NumPy für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "matrix_size": size,
                        "error_type": "accuracy",
                        "error_value": float(error),
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixmultiplikation für {size}x{size}: {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_multiply",
                    "matrix_size": size,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        # Teste mit Edge Cases
        for case_name, matrix in test_matrices["edge_cases"].items():
            try:
                # Tests für Edge Cases
                self.logger.debug(f"Teste Edge-Case '{case_name}'")
                original_result = self.matrix_core.matrix_multiply(matrix, matrix)
                
                # NumPy-Referenz
                np_result = np.matmul(matrix, matrix)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für Edge-Case '{case_name}'"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "case": case_name,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixmultiplikation für Edge-Case '{case_name}': {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_multiply",
                    "case": case_name,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        self.stats["tested_functions"] += 1
        self.stats["identified_issues"] += len(issues)
        self.stats["details"]["matrix_multiply"] = issues
        
        self.logger.info(f"Matrixmultiplikation analysiert: {len(issues)} Probleme gefunden.")
        return issues

    def analyze_matrix_inverse(self):
        """Analysiert die Matrixinversion auf numerische Stabilitätsprobleme."""
        self.logger.info("Analysiere Matrixinversion...")
        test_matrices = self.generate_test_matrices(sizes=[10, 50, 100], condition_numbers=[1e2, 1e4, 1e6])
        issues = []
        
        # Teste mit Zufallsmatrizen
        for size, matrix in test_matrices["random"].items():
            try:
                # Original-Implementierung testen
                self.logger.debug(f"Teste Originalinversion mit {size}x{size} Matrix")
                original_result = self.matrix_core.matrix_inverse(matrix)
                
                # NumPy-Referenz
                np_result = np.linalg.inv(matrix)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
                # Prüfe Genauigkeit: A * A^-1 ≈ I
                identity_check = matrix @ original_result
                error = np.max(np.abs(identity_check - np.eye(size)))
                if error > self.threshold * 10:  # Höhere Toleranz für Inversion
                    error_msg = f"Großer Fehler ({error:.2e}) in Inversion für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "error_type": "accuracy",
                        "error_value": float(error),
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixinversion für {size}x{size}: {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_inverse",
                    "matrix_size": size,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        # Teste mit schlecht konditionierten Matrizen
        for size in test_matrices["ill_conditioned"]:
            for cond, matrix in test_matrices["ill_conditioned"][size].items():
                try:
                    self.logger.debug(f"Teste Inversion für {size}x{size} Matrix mit κ={cond:.1e}")
                    original_result = self.matrix_core.matrix_inverse(matrix)
                    
                    # Fehler berechnen
                    if np.isnan(original_result).any() or np.isinf(original_result).any():
                        error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        issues.append({
                            "function": "matrix_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "nan_inf",
                            "description": error_msg
                        })
                    
                except Exception as e:
                    error_msg = f"Exception in Matrixinversion für {size}x{size} mit κ={cond:.1e}: {str(e)}"
                    self.logger.error(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "condition": float(cond),
                        "error_type": "exception",
                        "exception": str(e),
                        "description": error_msg
                    })
        
        # Teste SPD-Matrizen für Cholesky-Inverse
        spd_issues = []
        for size in test_matrices["spd"]:
            for cond, matrix in test_matrices["spd"][size].items():
                try:
                    self.logger.debug(f"Teste SPD-Inversion für {size}x{size} Matrix mit κ={cond:.1e}")
                    
                    # Test auf SPD
                    is_spd = self.matrix_core._is_spd(matrix)
                    if not is_spd:
                        error_msg = f"SPD-Erkennung versagt für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_is_spd",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "detection",
                            "description": error_msg
                        })
                        continue
                    
                    # Cholesky-Inversion testen
                    cholesky_result = self.matrix_core._cholesky_inverse(matrix)
                    
                    # Fehler berechnen
                    if np.isnan(cholesky_result).any() or np.isinf(cholesky_result).any():
                        error_msg = f"NaN/Inf in Cholesky-Inverse für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_cholesky_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "nan_inf",
                            "description": error_msg
                        })
                    
                    # Prüfe Genauigkeit: A * A^-1 ≈ I
                    identity_check = matrix @ cholesky_result
                    error = np.max(np.abs(identity_check - np.eye(size)))
                    if error > self.threshold * 10:
                        error_msg = f"Großer Fehler ({error:.2e}) in Cholesky-Inverse für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_cholesky_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "accuracy",
                            "error_value": float(error),
                            "description": error_msg
                        })
                    
                except Exception as e:
                    error_msg = f"Exception in Cholesky-Inverse für {size}x{size} mit κ={cond:.1e}: {str(e)}"
                    self.logger.error(error_msg)
                    spd_issues.append({
                        "function": "_cholesky_inverse",
                        "matrix_size": size,
                        "condition": float(cond),
                        "error_type": "exception",
                        "exception": str(e),
                        "description": error_msg
                    })
        
        # Füge SPD-Probleme hinzu
        issues.extend(spd_issues)
        
        self.stats["tested_functions"] += 2  # matrix_inverse und _cholesky_inverse
        self.stats["identified_issues"] += len(issues)
        self.stats["details"]["matrix_inverse"] = issues
        
        self.logger.info(f"Matrixinversion analysiert: {len(issues)} Probleme gefunden.")
        return issues
    
    def analyze_matrix_multiply(self):
        """Analysiert die Matrixmultiplikation auf numerische Stabilitätsprobleme."""
        self.logger.info("Analysiere Matrixmultiplikation...")
        test_matrices = self.generate_test_matrices()
        issues = []
        
        # Teste mit Zufallsmatrizen
        for size, matrix_a in test_matrices["random"].items():
            matrix_b = self._generate_stable_random_matrix(size)
            
            try:
                # Original-Implementierung testen
                self.logger.debug(f"Teste Originalmultiplikation mit {size}x{size} Matrix")
                original_result = self.matrix_core.matrix_multiply(matrix_a, matrix_b)
                
                # NumPy-Referenz
                np_result = np.matmul(matrix_a, matrix_b)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "matrix_size": size,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
                # Unterschied zu NumPy-Referenz
                error = np.max(np.abs(original_result - np_result))
                if error > self.threshold:
                    error_msg = f"Großer Fehler ({error:.2e}) vs. NumPy für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "matrix_size": size,
                        "error_type": "accuracy",
                        "error_value": float(error),
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixmultiplikation für {size}x{size}: {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_multiply",
                    "matrix_size": size,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        # Teste mit Edge Cases
        for case_name, matrix in test_matrices["edge_cases"].items():
            try:
                # Tests für Edge Cases
                self.logger.debug(f"Teste Edge-Case '{case_name}'")
                original_result = self.matrix_core.matrix_multiply(matrix, matrix)
                
                # NumPy-Referenz
                np_result = np.matmul(matrix, matrix)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für Edge-Case '{case_name}'"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_multiply",
                        "case": case_name,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixmultiplikation für Edge-Case '{case_name}': {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_multiply",
                    "case": case_name,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        self.stats["tested_functions"] += 1
        self.stats["identified_issues"] += len(issues)
        self.stats["details"]["matrix_multiply"] = issues
        
        self.logger.info(f"Matrixmultiplikation analysiert: {len(issues)} Probleme gefunden.")
        return issues

    def analyze_matrix_inverse(self):
        """Analysiert die Matrixinversion auf numerische Stabilitätsprobleme."""
        self.logger.info("Analysiere Matrixinversion...")
        test_matrices = self.generate_test_matrices(sizes=[10, 50, 100], condition_numbers=[1e2, 1e4, 1e6])
        issues = []
        
        # Teste mit Zufallsmatrizen
        for size, matrix in test_matrices["random"].items():
            try:
                # Original-Implementierung testen
                self.logger.debug(f"Teste Originalinversion mit {size}x{size} Matrix")
                original_result = self.matrix_core.matrix_inverse(matrix)
                
                # NumPy-Referenz
                np_result = np.linalg.inv(matrix)
                
                # Fehler berechnen
                if np.isnan(original_result).any() or np.isinf(original_result).any():
                    error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "error_type": "nan_inf",
                        "description": error_msg
                    })
                
                # Prüfe Genauigkeit: A * A^-1 ≈ I
                identity_check = matrix @ original_result
                error = np.max(np.abs(identity_check - np.eye(size)))
                if error > self.threshold * 10:  # Höhere Toleranz für Inversion
                    error_msg = f"Großer Fehler ({error:.2e}) in Inversion für {size}x{size} Matrix"
                    self.logger.warning(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "error_type": "accuracy",
                        "error_value": float(error),
                        "description": error_msg
                    })
                
            except Exception as e:
                error_msg = f"Exception in Matrixinversion für {size}x{size}: {str(e)}"
                self.logger.error(error_msg)
                issues.append({
                    "function": "matrix_inverse",
                    "matrix_size": size,
                    "error_type": "exception",
                    "exception": str(e),
                    "description": error_msg
                })
        
        # Teste mit schlecht konditionierten Matrizen
        for size in test_matrices["ill_conditioned"]:
            for cond, matrix in test_matrices["ill_conditioned"][size].items():
                try:
                    self.logger.debug(f"Teste Inversion für {size}x{size} Matrix mit κ={cond:.1e}")
                    original_result = self.matrix_core.matrix_inverse(matrix)
                    
                    # Fehler berechnen
                    if np.isnan(original_result).any() or np.isinf(original_result).any():
                        error_msg = f"NaN/Inf in Ergebnis für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        issues.append({
                            "function": "matrix_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "nan_inf",
                            "description": error_msg
                        })
                    
                except Exception as e:
                    error_msg = f"Exception in Matrixinversion für {size}x{size} mit κ={cond:.1e}: {str(e)}"
                    self.logger.error(error_msg)
                    issues.append({
                        "function": "matrix_inverse",
                        "matrix_size": size,
                        "condition": float(cond),
                        "error_type": "exception",
                        "exception": str(e),
                        "description": error_msg
                    })
        
        # Teste SPD-Matrizen für Cholesky-Inverse
        spd_issues = []
        for size in test_matrices["spd"]:
            for cond, matrix in test_matrices["spd"][size].items():
                try:
                    self.logger.debug(f"Teste SPD-Inversion für {size}x{size} Matrix mit κ={cond:.1e}")
                    
                    # Test auf SPD
                    is_spd = self.matrix_core._is_spd(matrix)
                    if not is_spd:
                        error_msg = f"SPD-Erkennung versagt für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_is_spd",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "detection",
                            "description": error_msg
                        })
                        continue
                    
                    # Cholesky-Inversion testen
                    cholesky_result = self.matrix_core._cholesky_inverse(matrix)
                    
                    # Fehler berechnen
                    if np.isnan(cholesky_result).any() or np.isinf(cholesky_result).any():
                        error_msg = f"NaN/Inf in Cholesky-Inverse für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_cholesky_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "nan_inf",
                            "description": error_msg
                        })
                    
                    # Prüfe Genauigkeit: A * A^-1 ≈ I
                    identity_check = matrix @ cholesky_result
                    error = np.max(np.abs(identity_check - np.eye(size)))
                    if error > self.threshold * 10:
                        error_msg = f"Großer Fehler ({error:.2e}) in Cholesky-Inverse für {size}x{size} Matrix mit κ={cond:.1e}"
                        self.logger.warning(error_msg)
                        spd_issues.append({
                            "function": "_cholesky_inverse",
                            "matrix_size": size,
                            "condition": float(cond),
                            "error_type": "accuracy",
                            "error_value": float(error),
                            "description": error_msg
                        })
                    
                except Exception as e:
                    error_msg = f"Exception in Cholesky-Inverse für {size}x{size} mit κ={cond:.1e}: {str(e)}"
                    self.logger.error(error_msg)
                    spd_issues.append({
                        "function": "_cholesky_inverse",
                        "matrix_size": size,
                        "condition": float(cond),
                        "error_type": "exception",
                        "exception": str(e),
                        "description": error_msg
                    })
        
        # Füge SPD-Probleme hinzu
        issues.extend(spd_issues)
        
        self.stats["tested_functions"] += 2  # matrix_inverse und _cholesky_inverse
        self.stats["identified_issues"] += len(issues)
        self.stats["details"]["matrix_inverse"] = issues
        
        self.logger.info(f"Matrixinversion analysiert: {len(issues)} Probleme gefunden.")
        return issues
    
    def _generate_matrix_multiply_fix(self, issues):
        """Generiert einen Fix für die Matrixmultiplikation."""
        multiply_issues = [issue for issue in issues.get("matrix_multiply", []) 
                          if issue["function"] == "matrix_multiply"]
        
        if not multiply_issues:
            self.logger.info("Keine Fixes für Matrixmultiplikation erforderlich.")
            return None
            
        fix_code = """# Optimierte Matrixmultiplikation mit verbesserter numerischer Stabilität
# Generiert vom VX-MATRIX Stabilizer

import numpy as np
import warnings

# Konstanten für numerische Stabilität
EPSILON = 1e-10

def optimized_stable_matrix_multiply(a, b):
    # Hochstabile Matrixmultiplikation mit umfassender numerischer Absicherung.
    
    Bietet verbesserte numerische Stabilität für Edge Cases wie:
    - Matrizen mit sehr kleinen oder großen Werten
    - Matrizen mit NaN oder Inf-Werten
    - Schlecht konditionierte Matrizen
    
    Args:
        a: Erste Matrix
        b: Zweite Matrix
        
    Returns:
        Matrix-Produkt a·b mit verbesserter numerischer Stabilität
    """
    # Überprüfe, ob Matrizen multiplizierbar sind
    if a.shape[1] != b.shape[0]:
        raise ValueError(f"Matrizen mit Formen {a.shape} und {b.shape} können nicht multipliziert werden.")
    
    # Ersetze NaN und Inf durch sichere Werte
    a_safe = np.nan_to_num(a, nan=0.0, posinf=1e30, neginf=-1e30)
    b_safe = np.nan_to_num(b, nan=0.0, posinf=1e30, neginf=-1e30)
    
    # Skaliere die Matrizen für bessere numerische Eigenschaften
    a_max = np.max(np.abs(a_safe)) if a_safe.size > 0 else 1.0
    b_max = np.max(np.abs(b_safe)) if b_safe.size > 0 else 1.0
    
    # Sichere Skalierung mit Prüfung auf sehr kleine Werte
    a_scale = a_max if a_max > EPSILON else 1.0
    b_scale = b_max if b_max > EPSILON else 1.0
    
    a_scaled = a_safe / a_scale
    b_scaled = b_safe / b_scale
    
    # Führe Matrixmultiplikation durch
    try:
        result = np.matmul(a_scaled, b_scaled)
        
        # Skaliere Ergebnis zurück
        result = result * (a_scale * b_scale)
        
        # Überprüfe auf numerische Instabilitäten im Ergebnis
        if not np.all(np.isfinite(result)):
            warnings.warn("Numerische Instabilität in der Matrixmultiplikation erkannt. Führe regularisierte Berechnung durch.")
            # Versuche Regularisierung
            a_reg = a_scaled + np.eye(a_scaled.shape[0], a_scaled.shape[1]) * EPSILON if a_scaled.shape[0] <= a_scaled.shape[1] else a_scaled
            b_reg = b_scaled + np.eye(b_scaled.shape[0], b_scaled.shape[1]) * EPSILON if b_scaled.shape[1] <= b_scaled.shape[0] else b_scaled
            result = np.matmul(a_reg, b_reg) * (a_scale * b_scale)
        
        return result
        
    except Exception as e:
        # Fallback bei Ausnahmen
        warnings.warn(f"Fehler bei Matrixmultiplikation: {str(e)}. Verwende fallback-Methode.")
        
        # Fallback-Methode
        result = np.zeros((a_safe.shape[0], b_safe.shape[1]))
        for i in range(a_safe.shape[0]):
            for j in range(b_safe.shape[1]):
                val = 0.0
                for k in range(a_safe.shape[1]):
                    val += a_scaled[i, k] * b_scaled[k, j]
                result[i, j] = val * (a_scale * b_scale)
        
        return result
    
    def generate_fixes(self, issues):
        """Generiert Code-Fixes für die identifizierten Probleme."""
        self.logger.info("Generiere Fixes...")        
        fixes = {
            "matrix_multiply": self._generate_matrix_multiply_fix(issues),
            "matrix_inverse": self._generate_matrix_inverse_fix(issues),
            "cholesky_inverse": self._generate_cholesky_inverse_fix(issues)
        }
        
        # Speichere die Fixes
        for func_name, fix_code in fixes.items():
            if fix_code:
                # Generiere ein Python-Modul mit dem Fix
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                fix_file = os.path.join(FIXES_DIR, f"{func_name}_fix_{timestamp}.py")
                with open(fix_file, 'w') as f:
                    f.write(fix_code)
                
                self.logger.info(f"Fix für {func_name} gespeichert in: {fix_file}")
                self.stats["generated_patches"] += 1
        
        return fixes
    
    def _generate_matrix_multiply_fix(self, issues):
        """Generiert einen Fix für die Matrixmultiplikation."""
        multiply_issues = [issue for issue in issues.get("matrix_multiply", []) if issue["function"] == "matrix_multiply"]
        
        if not multiply_issues:
            self.logger.info("Keine Fixes für Matrixmultiplikation erforderlich.")
            return None
        
        fix_code = '''# Optimierte Matrixmultiplikation mit verbesserter numerischer Stabilität
# Generiert vom VX-MATRIX Stabilizer

import numpy as np
import warnings

# Konstanten für numerische Stabilität
EPSILON = 1e-10

def optimized_stable_matrix_multiply(a, b):
    """Hochstabile Matrixmultiplikation mit umfassender numerischer Absicherung.
    
    Bietet verbesserte numerische Stabilität für Edge Cases wie:
    - Matrizen mit sehr kleinen oder großen Werten
    - Matrizen mit NaN oder Inf-Werten
    - Schlecht konditionierte Matrizen
    
    Args:
        a: Erste Matrix
        b: Zweite Matrix
        
    Returns:
        Matrix-Produkt a·b mit verbesserter numerischer Stabilität
    """
    # Überprüfe, ob Matrizen multiplizierbar sind
    if a.shape[1] != b.shape[0]:
        raise ValueError(f"Matrizen mit Formen {a.shape} und {b.shape} können nicht multipliziert werden.")
    
    # Ersetze NaN und Inf durch sichere Werte
    a_safe = np.nan_to_num(a, nan=0.0, posinf=1e30, neginf=-1e30)
    b_safe = np.nan_to_num(b, nan=0.0, posinf=1e30, neginf=-1e30)
    
    # Skaliere die Matrizen für bessere numerische Eigenschaften
    a_max = np.max(np.abs(a_safe)) if a_safe.size > 0 else 1.0
    b_max = np.max(np.abs(b_safe)) if b_safe.size > 0 else 1.0
    
    # Sichere Skalierung mit Prüfung auf sehr kleine Werte
    a_scale = a_max if a_max > EPSILON else 1.0
    b_scale = b_max if b_max > EPSILON else 1.0
    
    a_scaled = a_safe / a_scale
    b_scaled = b_safe / b_scale
    
    # Führe Matrixmultiplikation durch
    try:
        result = np.matmul(a_scaled, b_scaled)
        
        # Skaliere Ergebnis zurück
        result = result * (a_scale * b_scale)
        
        # Überprüfe auf numerische Instabilitäten im Ergebnis
        if not np.all(np.isfinite(result)):
            warnings.warn("Numerische Instabilität in der Matrixmultiplikation erkannt. Führe regularisierte Berechnung durch.")
            # Versuche Regularisierung
            a_reg = a_scaled + np.eye(a_scaled.shape[0], a_scaled.shape[1]) * EPSILON if a_scaled.shape[0] <= a_scaled.shape[1] else a_scaled
            b_reg = b_scaled + np.eye(b_scaled.shape[0], b_scaled.shape[1]) * EPSILON if b_scaled.shape[1] <= b_scaled.shape[0] else b_scaled
            result = np.matmul(a_reg, b_reg) * (a_scale * b_scale)
        
        return result
        
    except Exception as e:
        # Fallback bei Ausnahmen
        warnings.warn(f"Fehler bei Matrixmultiplikation: {str(e)}. Verwende fallback-Methode.")
        
        # Fallback-Methode
        result = np.zeros((a_safe.shape[0], b_safe.shape[1]))
        for i in range(a_safe.shape[0]):
            for j in range(b_safe.shape[1]):
                val = 0.0
                for k in range(a_safe.shape[1]):
                    val += a_scaled[i, k] * b_scaled[k, j]
                result[i, j] = val * (a_scale * b_scale)
        
        return result
'''
        
        self.logger.info("Fix für Matrixmultiplikation generiert.")
        return fix_code
    
    def _generate_matrix_inverse_fix(self, issues):
        """Generiert einen Fix für die Matrixinversion."""
        inverse_issues = [issue for issue in issues.get("matrix_inverse", []) 
                          if issue["function"] == "matrix_inverse"]
        
        if not inverse_issues:
            self.logger.info("Keine Fixes für Matrixinversion erforderlich.")
            return None
            
        fix_code = '''# Optimierte Matrixinversion mit verbesserter numerischer Stabilität
# Generiert vom VX-MATRIX Stabilizer

import numpy as np
from scipy import linalg
import warnings

# Konstanten für numerische Stabilität
EPSILON = 1e-10  # Konstante für numerische Stabilität
REGULARIZATION_STRENGTH = 1e-6  # Tikhonov-Regularisierung

def is_spd_stable(A, epsilon=EPSILON):
    """Überprüft, ob eine Matrix symmetrisch positiv definit ist mit verbesserter Stabilität."""
    if A.shape[0] != A.shape[1]:
        return False
    
    # Überprüfe Symmetrie mit Toleranz
    if not np.allclose(A, A.T, rtol=epsilon):
        return False
    
    try:
        # Überprüfe positive Definitheit durch Cholesky-Zerlegung
        # Verwende try-except anstatt eigenvalue computation für Effizienz
        linalg.cholesky(A + np.eye(A.shape[0]) * epsilon)
        return True
    except np.linalg.LinAlgError:
        return False

def optimized_stable_matrix_inverse(A, method='auto'):
    """Optimierte, numerisch stabile Matrixinversion mit mehreren Methoden.
    
    Parameter:
    ----------
    A : ndarray
        Die zu invertierende Matrix
    method : str
        Methode zur Inversion: 'auto', 'svd', 'lu', 'cholesky'
        
    Returns:
    --------
    ndarray
        Die invertierte Matrix
    """
    if A.size == 0:
        warnings.warn("Leere Matrix kann nicht invertiert werden")
        return np.array([])
    
    # Skalierungsfaktor berechnen, um numerische Stabilität zu verbessern
    scale = np.max(np.abs(A))
    if scale < EPSILON:
        warnings.warn("Matrix enthält nur sehr kleine Werte, verwende Regularisierung")
        # Vermeidung extremer Skalierungen
        scale = 1.0
        # Regularisiere die Matrix
        A_scaled = A + np.eye(A.shape[0]) * REGULARIZATION_STRENGTH
    else:
        # Skaliere die Matrix für bessere numerische Eigenschaften
        A_scaled = A / scale
    
    # Fallback-Mechanismus mit verschiedenen numerischen Methoden
    if method == 'auto':
        # Auto-Methode basierend auf Matrixeigenschaften wählen
        if is_spd_stable(A_scaled, epsilon=EPSILON):
            method = 'cholesky'  # Schneller und stabiler für SPD-Matrizen
        elif A_scaled.shape[0] <= 100:
            method = 'svd'       # Stabiler für kleine Matrizen
        else:
            method = 'lu'        # Effizienter für große Matrizen
    
    try:
        if method == 'svd':
            # SVD-basierte Inversion mit verbesserten Stabilitätskontrollen
            U, s, Vh = linalg.svd(A_scaled, full_matrices=False)
            
            # Kontrolliere kleine Singulärwerte
            s_max = np.max(s)
            tol = EPSILON * max(A_scaled.shape) * s_max
            s_inv = np.zeros_like(s)
            
            # Invertiere nur Singulärwerte über Schwellenwert
            mask = s > tol
            s_inv[mask] = 1.0 / s[mask]
            
            # Überprüfe Konditionszahl und warne bei schlecht konditionierten Matrizen
            condition_number = s_max / np.min(s[mask]) if np.any(mask) else np.inf
            if condition_number > 1e8:
                warnings.warn(f"Matrix ist schlecht konditioniert (Konditionszahl: {condition_number:.2e})")
            
            # Berechne die Inverse und skaliere zurück
            A_inv = np.matmul(np.matmul(Vh.T, np.diag(s_inv)), U.T) * (1.0 / scale)
            
        elif method == 'cholesky':
            # Verwende optimierte Cholesky-Inversion für SPD-Matrizen
            A_inv = optimized_stable_cholesky_inverse(A_scaled) * (1.0 / scale)
            
        elif method == 'lu':
            # LU-basierte Inversion mit besserer Fehlerbehandlung
            with warnings.catch_warnings():
                warnings.filterwarnings('error')  # Verwandle Warnungen in Fehler für bessere Behandlung
                try:
                    A_inv = linalg.inv(A_scaled, overwrite_a=False) * (1.0 / scale)
                except (np.linalg.LinAlgError, Warning) as e:
                    # Fallback auf regularisierte Inversion
                    warnings.warn(f"LU-Inversion fehlgeschlagen, verwende regularisierte SVD: {str(e)}")
                    # Füge Regularisierung hinzu
                    A_reg = A_scaled + np.eye(A_scaled.shape[0]) * REGULARIZATION_STRENGTH
                    U, s, Vh = linalg.svd(A_reg, full_matrices=False)
                    s_max = np.max(s)
                    tol = EPSILON * max(A_scaled.shape) * s_max
                    s_inv = np.zeros_like(s)
                    mask = s > tol
                    s_inv[mask] = 1.0 / s[mask]
                    A_inv = np.matmul(np.matmul(Vh.T, np.diag(s_inv)), U.T) * (1.0 / scale)
        else:
            raise ValueError(f"Unbekannte Methode: {method}")
        
        return A_inv
        
    except np.linalg.LinAlgError as e:
        # Bei Fehler in allen Methoden, verwende stark regularisierte SVD
        warnings.warn(f"Inversion fehlgeschlagen, verwende stark regularisierte SVD als letzten Ausweg: {str(e)}")
        # Starke Regularisierung als letzte Option
        A_reg = A_scaled + np.eye(A_scaled.shape[0]) * (REGULARIZATION_STRENGTH * 10.0)
        U, s, Vh = linalg.svd(A_reg, full_matrices=False)
        s_max = np.max(s)
        tol = EPSILON * max(A_scaled.shape) * s_max
        s_inv = np.zeros_like(s)
        mask = s > tol
        s_inv[mask] = 1.0 / s[mask]
        return np.matmul(np.matmul(Vh.T, np.diag(s_inv)), U.T) * (1.0 / scale)

def optimized_stable_cholesky_inverse(A):
    """Optimierte, numerisch stabile Matrixinversion via Cholesky für SPD-Matrizen.
    
    Diese Funktion ist spezialisiert für symmetrische, positiv definite Matrizen.
    """
    try:
        # Versuche direkte Cholesky-Zerlegung
        L = linalg.cholesky(A, lower=True)  # A = L @ L.T
        # Löse das System mit triangulären Matrizen (effizienter als vollständige Inversion)
        identity = np.eye(A.shape[0])
        # Löse L @ Y = I für Y (vorwärts)
        Y = linalg.solve_triangular(L, identity, lower=True)
        # Löse L.T @ X = Y für X (rückwärts)
        A_inv = linalg.solve_triangular(L.T, Y, lower=False)
        return A_inv
        
    except np.linalg.LinAlgError:
        # Bei Fehler, versuche mit verbesserter Konditionierung
        try:
            # Füge minimale Regularisierung hinzu
            A_reg = A + np.eye(A.shape[0]) * REGULARIZATION_STRENGTH
            L = linalg.cholesky(A_reg, lower=True)
            identity = np.eye(A.shape[0])
            Y = linalg.solve_triangular(L, identity, lower=True)
            A_inv = linalg.solve_triangular(L.T, Y, lower=False)
            return A_inv
            
        except np.linalg.LinAlgError as e:
            # Fallback auf Standardinversion wenn Cholesky komplett fehlschlägt
            warnings.warn(f"Cholesky-Inversion fehlgeschlagen, Fallback auf SVD: {str(e)}")
            # Verwende SVD als Fallback
            U, s, Vh = linalg.svd(A, full_matrices=False)
            s_max = np.max(s)
            tol = EPSILON * max(A.shape) * s_max
            s_inv = np.zeros_like(s)
            mask = s > tol
            s_inv[mask] = 1.0 / s[mask]
            return np.matmul(np.matmul(Vh.T, np.diag(s_inv)), U.T)

def is_spd_stable(matrix, tol=1e-8):
    """Verbesserte Prüfung auf symmetrisch positiv-definite Matrizen."""
    # Sicherstelle, dass die Matrix quadratisch ist
    if matrix.shape[0] != matrix.shape[1]:
        return False
        
    # Sicherstelle, dass die Matrix symmetrisch ist (mit Toleranz)
    if not np.allclose(matrix, matrix.T, atol=tol):
        return False
    
    # Prüfe auf positive Definitheit, indem wir versuchen, die Cholesky-Zerlegung durchzuführen
    try:
        # Füge eine kleine Regularisierung hinzu, um numerische Instabilitäten zu bewältigen
        regularized_matrix = matrix + np.eye(matrix.shape[0]) * tol
        linalg.cholesky(regularized_matrix)
        return True
    except np.linalg.LinAlgError:
        return False

def optimized_stable_matrix_inverse(matrix):
    """Hochstabile Matrixinversion mit umfassender numerischer Absicherung."""
    # Sicherstellen, dass die Matrix ein NumPy-Array ist
    if not isinstance(matrix, np.ndarray):
        matrix = np.array(matrix, dtype=np.float64)
    
    # Prüfen, ob die Matrix quadratisch ist
    n = matrix.shape[0]
    if n != matrix.shape[1]:
        raise ValueError(f"Matrix muss quadratisch sein, ist aber {matrix.shape}")
    
    # Numerische Vorbehandlung
    epsilon = np.finfo(float).eps
    matrix_safe = np.nan_to_num(matrix, nan=epsilon, posinf=1e38, neginf=-1e38)
    
    # 1. Prüfe auf SPD für Cholesky-Inversion
    if is_spd_stable(matrix_safe):
        try:
            # Verwende Cholesky-Inversion für SPD-Matrizen
            return optimized_stable_cholesky_inverse(matrix_safe)
        except Exception as e:
            warnings.warn(f"Cholesky-Inversion fehlgeschlagen: {e}. Fallback auf Standard-Inversion.")
    
    # 2. Versuche Standard-Inversion mit Tikhonov-Regularisierung
    # Schätze Konditionszahl und wende bei Bedarf Regularisierung an
    try:
        s = linalg.svdvals(matrix_safe)
        condition = s[0] / s[-1] if s[-1] > epsilon*10 else float('inf')
        
        # Adaptive Regularisierung basierend auf Konditionszahl
        if condition > 1e6:
            # Matrix ist schlecht konditioniert - verwende adaptive Tikhonov-Regularisierung
            diag_avg = np.abs(np.mean(np.diag(matrix_safe)))
            lambda_factor = max(epsilon*100, diag_avg * min(1e-6, 1.0/condition))
            
            # Anwendung der Regularisierung
            identity = np.eye(n)
            regularized = matrix_safe + lambda_factor * identity
            try:
                return np.linalg.inv(regularized)
            except Exception:
                # Wenn das fehlschlägt, versuche die Pseudoinverse
                return np.linalg.pinv(regularized)
    except Exception as e:
        warnings.warn(f"Konditionszahl-Berechnung fehlgeschlagen: {e}. Verwende direkte Inversion.")
    
    # 3. Standard-Inversion als letzten Ausweg mit Fehlerbehandlung
    try:
        return np.linalg.inv(matrix_safe)
    except Exception:
        # Letzte Rettung: Pseudoinverse als robuster Fallback
        warnings.warn("Standard-Inversion fehlgeschlagen. Verwende Pseudoinverse.")
        return np.linalg.pinv(matrix_safe, rcond=epsilon*100)
'''

        self.logger.info("Fix für Matrixinversion generiert.")
        return fix_code
def optimized_stable_cholesky_inverse(matrix):
    """Optimierte Cholesky-Inversion mit verbesserter Fehlerbehandlung."""
    n = matrix.shape[0]
    epsilon = np.finfo(float).eps
    
    # Kleine Regularisierung für numerische Stabilität
    diag_avg = np.mean(np.diag(matrix))
    reg_factor = max(epsilon*10, diag_avg * 1e-12)
    matrix_reg = matrix.copy()
    np.fill_diagonal(matrix_reg, np.diag(matrix_reg) + reg_factor)
    
    try:
        # Verwende SciPy's optimierte Implementierung
        L = linalg.cholesky(matrix_reg, lower=True)
        identity = np.eye(n)
        
        # Löse das System für jede Spalte der Einheitsmatrix
        inverse = np.zeros((n, n), dtype=matrix.dtype)
        for i in range(n):
            b = identity[:, i]
            # Vorwärtssubstitution: L·y = b
            y = linalg.solve_triangular(L, b, lower=True)
            # Rückwärtssubstitution: L^T·x = y
            x = linalg.solve_triangular(L.T, y, lower=False)
            inverse[:, i] = x
        
        return inverse
    except Exception as e:
        # Bei Fehlern: Weiterleiten an die Standard-Inversion
        raise ValueError(f"Cholesky-Inversion fehlgeschlagen: {e}")
"""
        
    except np.linalg.LinAlgError as e:
        # Fallback bei numerischen Problemen
        warnings.warn(f"Cholesky-Zerlegung fehlgeschlagen: {str(e)}. Verwende Fallback-Methode.")
        
        # Stärkere Regularisierung versuchen
        stronger_reg_factor = max(epsilon*100, diag_avg * 1e-8)
        matrix_reg = matrix.copy()
        np.fill_diagonal(matrix_reg, np.diag(matrix_reg) + stronger_reg_factor)
        
        try:
            L = linalg.cholesky(matrix_reg, lower=True)
            identity = np.eye(n)
    def patch_matrix_core(self, fixes):
        """Wendet Fixes auf die Matrix-Core-Implementierung an."""
        if self.mode != "fix":
            self.logger.info("Patches werden im Analyse-Modus nicht angewendet.")
            return
        
        # Prüfe, ob Fixes verfügbar sind
        if not any(fixes.values()):
            self.logger.info("Keine Fixes zum Anwenden verfügbar.")
            return
        
        self.logger.info("Wende Patches auf matrix_core.py an...")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Matrix-Core-Datei
        matrix_core_path = os.path.join(root_dir, "core", "matrix_core.py")
        patched_file_path = os.path.join(root_dir, "core", f"matrix_core_patched_{timestamp}.py")
        
        # Lese die Original-Datei
        with open(matrix_core_path, 'r') as f:
            core_content = f.read()
        
        # Wende Patches an
        patched_content = core_content
        patched = False
        
        # 1. Patch für matrix_multiply
        if fixes["matrix_multiply"]:
            # Erstelle den Import
            import_code = "\n# Import des stabilisierten Matrix-Operators\nfrom ..optimizers.fixes.matrix_multiply_fix_{} import optimized_stable_matrix_multiply\n".format(timestamp)
            
            # Füge vor "class MatrixCore" ein
            patched_content = patched_content.replace("class MatrixCore", import_code + "\nclass MatrixCore")
            patched = True
            self.stats["fixed_issues"] += 1
        
        # 2. Patch für matrix_inverse
        if fixes["matrix_inverse"]:
            # Erstelle den Import
            import_code = "\n# Import der stabilisierten Matrix-Inversion\nfrom ..optimizers.fixes.matrix_inverse_fix_{} import optimized_stable_matrix_inverse, is_spd_stable, optimized_stable_cholesky_inverse\n".format(timestamp)
            
            # Füge vor "class MatrixCore" ein, falls noch nicht geschehen
            if "from ..optimizers.fixes" not in patched_content:
                patched_content = patched_content.replace("class MatrixCore", import_code + "\nclass MatrixCore")
            else:
                # Füge nach dem ersten Import ein
                split_point = patched_content.find("\nclass MatrixCore")
                patched_content = patched_content[:split_point] + import_code + patched_content[split_point:]
            
            patched = True
            self.stats["fixed_issues"] += 1
        
        if patched:
            # Speichere die gepatchte Datei
            with open(patched_file_path, 'w') as f:
                f.write(patched_content)
            
            self.logger.info(f"Gepatchte Matrix-Core-Implementierung gespeichert in: {patched_file_path}")
            
            # Erstelle eine Readme-Datei mit Installationsanweisungen
            readme_path = os.path.join(root_dir, "core", f"PATCH_README_{timestamp}.md")
            with open(readme_path, 'w') as f:
                f.write("""# VX-MATRIX Stabilitäts-Patch

Dieser Patch wurde automatisch vom VX-MATRIX Stabilizer generiert, um numerische Stabilitätsprobleme zu beheben.

## Installation

Um den Patch anzuwenden, folgen Sie diesen Schritten:

1. Sichern Sie die aktuelle Matrix-Core-Implementierung:
   ```bash
   cp matrix_core.py matrix_core_backup.py
   ```

2. Ersetzen Sie die aktuelle Implementierung durch die gepatchte Version:
   ```bash
   cp matrix_core_patched_{0}.py matrix_core.py
   ```

3. Stellen Sie sicher, dass die Fix-Module im `optimizers/fixes` Verzeichnis vorhanden sind.

## Enthaltene Fixes

{1}

## Generiert am

{2}
""".format(
                    timestamp,
                    "\n".join(["- " + k for k, v in fixes.items() if v]),
                    datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                ))
                
            self.logger.info(f"Installationsanweisungen erstellt in: {readme_path}")
        else:
            self.logger.info("Keine Patches angewendet.")
    
    def run(self):
        """Führt die Analyse und/oder Stabilisierung aus."""
        self.logger.info(f"Starte VX-MATRIX Stabilizer im {self.mode.upper()}-Modus...")
        start_time = time.time()
        
        # Analysiere Matrixoperationen
        issues = {}
        issues["matrix_multiply"] = self.analyze_matrix_multiply()
        issues["matrix_inverse"] = self.analyze_matrix_inverse()
        
        # Generiere Fixes, wenn erforderlich
        fixes = self.generate_fixes(issues)
        
        # Wende Patches an, wenn im Fix-Modus
        if self.mode == "fix":
            self.patch_matrix_core(fixes)
        
        # Statistiken aktualisieren
        self.stats["runtime"] = time.time() - start_time
        
        # Statistiken ausgeben
        self.logger.info("=== VX-MATRIX Stabilizer Zusammenfassung ===")
        self.logger.info(f"Modus: {self.mode.upper()}")
        self.logger.info(f"Getestete Funktionen: {self.stats['tested_functions']}")
        self.logger.info(f"Identifizierte Probleme: {self.stats['identified_issues']}")
        if self.mode == "fix":
            self.logger.info(f"Behobene Probleme: {self.stats['fixed_issues']}")
            self.logger.info(f"Generierte Patches: {self.stats['generated_patches']}")
        self.logger.info(f"Laufzeit: {self.stats['runtime']:.2f} Sekunden")
        
        # Speichere Statistiken
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        stats_file = os.path.join(LOGS_DIR, f"stabilizer_stats_{timestamp}.json")
        with open(stats_file, 'w') as f:
            json.dump(self.stats, f, indent=2)
        
        self.logger.info(f"Statistiken gespeichert in: {stats_file}")
        self.logger.info(f"Log-Datei: {self.log_file}")
        
        return self.stats


def main():
    """Hauptfunktion."""
    # Befehlszeilenargumente parsen
    parser = argparse.ArgumentParser(description="VX-MATRIX Numerische Stabilisierungstool")
    parser.add_argument("--mode", choices=["analyze", "fix"], default="analyze",
                        help="Betriebsmodus: nur analysieren oder auch Fixes anwenden")
    parser.add_argument("--verbosity", choices=["silent", "info", "debug"], default="info",
                        help="Log-Level")
    parser.add_argument("--threshold", type=float, default=1e-8,
                        help="Schwellenwert für numerische Stabilität")
    
    args = parser.parse_args()
    
    # Matrix-Stabilizer initialisieren und ausführen
    stabilizer = MatrixStabilizer(mode=args.mode, verbosity=args.verbosity, threshold=args.threshold)
    
    try:
        stats = stabilizer.run()
        return 0
    except Exception as e:
        print(f"Fehler: {str(e)}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
